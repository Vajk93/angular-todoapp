{"ast":null,"code":"import _asyncToGenerator from \"/Users/vajk/Desktop/angular-todoapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n  return new Promise((resolve, reject) => {\n    if (!indexedDB) {\n      reject('IndexedDB not available');\n    }\n    const request = indexedDB.open(dbName, version);\n    let db;\n    request.onsuccess = event => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = event => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = event => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\nfunction CreateObjectStore(_x, _x2, _x3, _x4, _x5) {\n  return _CreateObjectStore.apply(this, arguments);\n}\nfunction _CreateObjectStore() {\n  _CreateObjectStore = _asyncToGenerator(function* (indexedDB, dbName, version, storeSchemas, migrationFactory) {\n    return new Promise((resolve, reject) => {\n      if (!indexedDB) {\n        return;\n      }\n      const request = indexedDB.open(dbName, version);\n      request.onupgradeneeded = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (event) {\n          const database = event.target.result;\n          const storeCreationPromises = storeSchemas.map( /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* (storeSchema) {\n              if (!database.objectStoreNames.contains(storeSchema.store)) {\n                const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n                for (const schema of storeSchema.storeSchema) {\n                  objectStore.createIndex(schema.name, schema.keypath, schema.options);\n                }\n              }\n            });\n            return function (_x10) {\n              return _ref5.apply(this, arguments);\n            };\n          }());\n          yield Promise.all(storeCreationPromises);\n          const storeMigrations = migrationFactory && migrationFactory();\n          if (storeMigrations) {\n            const migrationKeys = Object.keys(storeMigrations).map(k => parseInt(k, 10)).filter(v => v > event.oldVersion).sort((a, b) => a - b);\n            for (const v of migrationKeys) {\n              storeMigrations[v](database, request.transaction);\n            }\n          }\n          database.close();\n          resolve();\n        });\n        return function (_x9) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n      request.onsuccess = e => {\n        e.target.result.close();\n        resolve();\n      };\n      request.onerror = error => {\n        reject(error);\n      };\n    });\n  });\n  return _CreateObjectStore.apply(this, arguments);\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n  if (!dbName || !version || !storeName) {\n    throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n  }\n  return new Observable(obs => {\n    try {\n      const newVersion = version + 1;\n      const request = indexedDB.open(dbName, newVersion);\n      request.onupgradeneeded = event => {\n        const database = event.target.result;\n        database.deleteObjectStore(storeName);\n        database.close();\n        console.log('onupgradeneeded');\n        obs.next(true);\n        obs.complete();\n      };\n      request.onerror = e => obs.error(e);\n    } catch (error) {\n      obs.error(error);\n    }\n  });\n}\nfunction validateStoreName(db, storeName) {\n  return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\nfunction createTransaction(db, options) {\n  const trans = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.onabort = options.abort;\n  return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n  return {\n    storeName,\n    dbMode: type,\n    error: e => {\n      reject(e);\n    },\n    abort: e => {\n      reject(e);\n    }\n  };\n}\nvar DBMode;\n(function (DBMode) {\n  DBMode[\"readonly\"] = \"readonly\";\n  DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\nclass NgxIndexedDBService {\n  constructor(dbConfigs, platformId) {\n    this.dbConfigs = dbConfigs;\n    this.platformId = platformId;\n    this.defaultDatabaseName = null;\n    this.isBrowser = isPlatformBrowser(this.platformId);\n    if (this.isBrowser) {\n      this.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      const dbConfigs = Object.values(this.dbConfigs);\n      const isOnlyConfig = dbConfigs.length === 1;\n      for (const dbConfig of dbConfigs) {\n        this.instanciateConfig(dbConfig, isOnlyConfig);\n      }\n    }\n  }\n  instanciateConfig(dbConfig, isOnlyConfig) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!dbConfig.name) {\n        throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n      }\n      if (!dbConfig.version) {\n        throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n      }\n      if ((dbConfig.isDefault ?? false) && _this.defaultDatabaseName) {\n        // A default DB is already configured, throw an error\n        throw new Error('NgxIndexedDB: Only one database can be set as default');\n      }\n      if ((dbConfig.isDefault ?? false) && !_this.defaultDatabaseName || isOnlyConfig) {\n        _this.defaultDatabaseName = dbConfig.name;\n        _this.selectedDb = dbConfig.name;\n      }\n      yield CreateObjectStore(_this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n      openDatabase(_this.indexedDB, dbConfig.name).then(db => {\n        if (db.version !== dbConfig.version) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n            console.warn(`Using latest version ${db.version}`);\n          }\n          _this.dbConfigs[dbConfig.name].version = db.version;\n        }\n      });\n    })();\n  }\n  get dbConfig() {\n    return this.dbConfigs[this.selectedDb];\n  }\n  /**\n   * The function return the current version of database\n   *\n   * @Return the current version of database as number\n   */\n  getDatabaseVersion() {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        obs.next(db.version);\n        obs.complete();\n      }).catch(err => obs.error(`error during get version of database => ${err} `));\n    });\n  }\n  /**\n   * Selects a database for the current context.\n   * @param {string} [databaseName=undefined] Database name to select.\n   */\n  selectDb(databaseName) {\n    databaseName = databaseName ?? this.defaultDatabaseName;\n    if (!databaseName) {\n      // Name is still null, it means that there is no default database set\n      // and the database name was not specified while calling a method\n      throw new Error(`No database name specified and no default database set.`);\n    }\n    if (!Object.keys(this.dbConfigs).includes(databaseName)) {\n      throw new Error(`NgxIndexedDB: Database ${databaseName} is not initialized.`);\n    }\n    this.selectedDb = databaseName;\n  }\n  /**\n   * Allows to create a new object store ad-hoc\n   * @param storeName The name of the store to be created\n   * @param migrationFactory The migration factory if exists\n   */\n  createObjectStore(storeSchema, migrationFactory) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const storeSchemas = [storeSchema];\n      yield CreateObjectStore(_this2.indexedDB, _this2.dbConfig.name, ++_this2.dbConfig.version, storeSchemas, migrationFactory);\n    })();\n  }\n  /**\n   * Adds new entry in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param value The entry to be added\n   * @param key The optional key for the entry\n   */\n  add(storeName, value, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n        request.onsuccess = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (evt) {\n            const result = evt.target.result;\n            const getRequest = objectStore.get(result);\n            getRequest.onsuccess = event => {\n              obs.next(event.target.result);\n              obs.complete();\n            };\n            getRequest.onerror = event => {\n              obs.error(event);\n            };\n          });\n          return function (_x6) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        request.onerror = event => {\n          obs.error(event);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Adds new entries in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param values The entries to be added containing optional key attribute\n   */\n  bulkAdd(storeName, values) {\n    const promises = new Promise((resolve, reject) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n        const objectStore = transaction.objectStore(storeName);\n        const results = values.map(value => {\n          return new Promise((resolve1, reject1) => {\n            const key = value.key;\n            delete value.key;\n            const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n            request.onsuccess = evt => {\n              const result = evt.target.result;\n              resolve1(result);\n            };\n          });\n        });\n        resolve(Promise.all(results));\n      }).catch(reason => reject(reason));\n    });\n    return from(promises);\n  }\n  /**\n   * Delete entries in the store and returns current entries in the store\n   * @param storeName The name of the store to add the item\n   * @param keys The keys to be deleted\n   */\n  bulkDelete(storeName, keys) {\n    const promises = keys.map(key => {\n      return new Promise((resolve, reject) => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.delete(key);\n          transaction.oncomplete = () => {\n            this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n              resolve(newValues);\n            });\n          };\n        }).catch(reason => reject(reason));\n      });\n    });\n    return from(Promise.all(promises));\n  }\n  /**\n   * Returns entry by key.\n   * @param storeName The name of the store to query\n   * @param key The entry key\n   */\n  getByKey(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.get(key);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n          obs.complete();\n        };\n        request.onerror = event => {\n          obs.error(event);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Retrieve multiple entries in the store\n   * @param storeName The name of the store to retrieve the items\n   * @param keys The ids entries to be retrieve\n   */\n  bulkGet(storeName, keys) {\n    const observables = keys.map(key => this.getByKey(storeName, key));\n    return new Observable(obs => {\n      combineLatest(observables).subscribe(values => {\n        obs.next(values);\n        obs.complete();\n      });\n    });\n  }\n  /**\n   * Returns entry by id.\n   * @param storeName The name of the store to query\n   * @param id The entry id\n   */\n  getByID(storeName, id) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.get(id);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns entry by index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param key The entry key.\n   */\n  getByIndex(storeName, indexName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.get(key);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Return all elements from one store\n   * @param storeName The name of the store to select the items\n   */\n  getAll(storeName) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.getAll();\n        request.onerror = evt => {\n          obs.error(evt);\n        };\n        request.onsuccess = ({\n          target: {\n            result: ResultAll\n          }\n        }) => {\n          obs.next(ResultAll);\n          obs.complete();\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Adds or updates a record in store with the given value and key. Return all items present in the store\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   */\n  update(storeName, value) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.put(value);\n        request.onsuccess = /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (evt) {\n            const result = evt.target.result;\n            const getRequest = objectStore.get(result);\n            getRequest.onsuccess = event => {\n              obs.next(event.target.result);\n              obs.complete();\n            };\n          });\n          return function (_x7) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Adds or updates a record in store with the given value and key. Return all items present in the store\n   * @param storeName The name of the store to update\n   * @param items The values to update in the DB\n   *\n   * @Return The return value is an Observable with the primary key of the object that was last in given array\n   *\n   * @error If the call to bulkPut fails the transaction will be aborted and previously inserted entities will be deleted\n   */\n  bulkPut(storeName, items) {\n    let transaction;\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        items.forEach((item, index) => {\n          const request = objectStore.put(item);\n          if (index === items.length - 1) {\n            request.onsuccess = evt => {\n              transaction.commit();\n              obs.next(evt.target.result);\n              obs.complete();\n            };\n          }\n          request.onerror = evt => {\n            transaction.abort();\n            obs.error(evt);\n          };\n        });\n      }).catch(reason => {\n        transaction?.abort();\n        obs.error(reason);\n      });\n    });\n  }\n  /**\n   * Returns all items from the store after delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  delete(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        objectStore.delete(key);\n        transaction.oncomplete = () => {\n          this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n            obs.next(newValues);\n            obs.complete();\n          });\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true from the store after a successful delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  deleteByKey(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        transaction.oncomplete = () => {\n          obs.next(true);\n          obs.complete();\n        };\n        objectStore.delete(key);\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true if successfully delete all entries from the store.\n   * @param storeName The name of the store to have the entries deleted\n   */\n  clear(storeName) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        objectStore.clear();\n        transaction.oncomplete = () => {\n          obs.next(true);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true if successfully delete the DB.\n   */\n  deleteDatabase() {\n    var _this3 = this;\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (db) {\n          yield db.close();\n          const deleteDBRequest = _this3.indexedDB.deleteDatabase(_this3.dbConfig.name);\n          deleteDBRequest.onsuccess = () => {\n            obs.next(true);\n            obs.complete();\n          };\n          deleteDBRequest.onerror = error => obs.error(error);\n          deleteDBRequest.onblocked = () => {\n            throw new Error(`Unable to delete database because it's blocked`);\n          };\n        });\n        return function (_x8) {\n          return _ref3.apply(this, arguments);\n        };\n      }()).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns the open cursor event\n   * @param storeName The name of the store to have the entries deleted\n   * @param keyRange The key range which the cursor should be open on\n   */\n  openCursor(storeName, keyRange, direction = 'next') {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange, direction);\n        request.onsuccess = event => {\n          obs.next(event);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Open a cursor by index filter.\n   * @param storeName The name of the store to query.\n   * @param indexName The index name to filter.\n   * @param keyRange The range value and criteria to apply on the index.\n   */\n  openCursorByIndex(storeName, indexName, keyRange, direction = 'next', mode = DBMode.readonly) {\n    const obs = new Subject();\n    openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n      validateBeforeTransaction(db, storeName, reason => {\n        obs.error(reason);\n      });\n      const transaction = createTransaction(db, optionsGenerator(mode, storeName, reason => {\n        obs.error(reason);\n      }, () => {\n        obs.next();\n      }));\n      const objectStore = transaction.objectStore(storeName);\n      const index = objectStore.index(indexName);\n      const request = index.openCursor(keyRange, direction);\n      request.onsuccess = event => {\n        obs.next(event);\n      };\n    }).catch(reason => obs.error(reason));\n    return obs;\n  }\n  /**\n   * Returns all items by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllByIndex(storeName, indexName, keyRange) {\n    const data = [];\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openCursor(keyRange);\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n          if (cursor) {\n            data.push(cursor.value);\n            cursor.continue();\n          } else {\n            obs.next(data);\n            obs.complete();\n          }\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns all primary keys by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllKeysByIndex(storeName, indexName, keyRange) {\n    const data = [];\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openKeyCursor(keyRange);\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n          if (cursor) {\n            data.push({\n              primaryKey: cursor.primaryKey,\n              key: cursor.key\n            });\n            cursor.continue();\n          } else {\n            obs.next(data);\n            obs.complete();\n          }\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n  count(storeName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.count(keyRange);\n        request.onerror = e => obs.error(e);\n        request.onsuccess = e => {\n          obs.next(e.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n  countByIndex(storeName, indexName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.count(keyRange);\n        request.onerror = e => obs.error(e);\n        request.onsuccess = e => {\n          obs.next(e.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Delete the store by name.\n   * @param storeName The name of the store to query\n   */\n  deleteObjectStore(storeName) {\n    return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n  }\n  static #_ = this.ɵfac = function NgxIndexedDBService_Factory(t) {\n    return new (t || NgxIndexedDBService)(i0.ɵɵinject(CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID));\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxIndexedDBService,\n    factory: NgxIndexedDBService.ɵfac\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxIndexedDBService, [{\n    type: Injectable\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [CONFIG_TOKEN]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }], null);\n})();\nclass NgxIndexedDBModule {\n  static forRoot(...dbConfigs) {\n    const value = {};\n    for (const dbConfig of dbConfigs) {\n      Object.assign(value, {\n        [dbConfig.name]: dbConfig\n      });\n    }\n    return {\n      ngModule: NgxIndexedDBModule,\n      providers: [NgxIndexedDBService, {\n        provide: CONFIG_TOKEN,\n        useValue: value\n      }]\n    };\n  }\n  static #_ = this.ɵfac = function NgxIndexedDBModule_Factory(t) {\n    return new (t || NgxIndexedDBModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxIndexedDBModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxIndexedDBModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [],\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };","map":{"version":3,"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","NgModule","isPlatformBrowser","CommonModule","Observable","from","combineLatest","Subject","take","openDatabase","indexedDB","dbName","version","upgradeCallback","Promise","resolve","reject","request","open","db","onsuccess","event","result","onerror","error","onupgradeneeded","CreateObjectStore","_x","_x2","_x3","_x4","_x5","_CreateObjectStore","apply","arguments","_asyncToGenerator","storeSchemas","migrationFactory","_ref4","database","target","storeCreationPromises","map","_ref5","storeSchema","objectStoreNames","contains","store","objectStore","createObjectStore","storeConfig","schema","createIndex","name","keypath","options","_x10","all","storeMigrations","migrationKeys","Object","keys","k","parseInt","filter","v","oldVersion","sort","a","b","transaction","close","_x9","e","DeleteObjectStore","storeName","Error","obs","newVersion","deleteObjectStore","console","log","next","complete","validateStoreName","validateBeforeTransaction","createTransaction","trans","dbMode","onabort","abort","optionsGenerator","type","DBMode","CONFIG_TOKEN","NgxIndexedDBService","constructor","dbConfigs","platformId","defaultDatabaseName","isBrowser","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","values","isOnlyConfig","length","dbConfig","instanciateConfig","_this","isDefault","selectedDb","objectStoresMeta","then","process","env","NODE_ENV","warn","getDatabaseVersion","catch","err","selectDb","databaseName","includes","_this2","add","value","key","readwrite","Boolean","_ref","evt","getRequest","get","_x6","bulkAdd","promises","results","resolve1","reject1","reason","bulkDelete","delete","oncomplete","getAll","pipe","subscribe","newValues","getByKey","readonly","bulkGet","observables","getByID","id","getByIndex","indexName","index","ResultAll","update","put","_ref2","_x7","bulkPut","items","forEach","item","commit","deleteByKey","clear","deleteDatabase","_this3","_ref3","deleteDBRequest","onblocked","_x8","openCursor","keyRange","direction","undefined","openCursorByIndex","mode","getAllByIndex","data","cursor","push","continue","getAllKeysByIndex","openKeyCursor","primaryKey","count","countByIndex","_","ɵfac","NgxIndexedDBService_Factory","t","ɵɵinject","_2","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","decorators","args","NgxIndexedDBModule","forRoot","assign","ngModule","providers","provide","useValue","NgxIndexedDBModule_Factory","ɵmod","ɵɵdefineNgModule","_3","ɵinj","ɵɵdefineInjector","imports","declarations"],"sources":["/Users/vajk/Desktop/angular-todoapp/node_modules/ngx-indexed-db/fesm2022/ngx-indexed-db.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n    return new Promise((resolve, reject) => {\n        if (!indexedDB) {\n            reject('IndexedDB not available');\n        }\n        const request = indexedDB.open(dbName, version);\n        let db;\n        request.onsuccess = (event) => {\n            db = request.result;\n            resolve(db);\n        };\n        request.onerror = (event) => {\n            reject(`IndexedDB error: ${request.error}`);\n        };\n        if (typeof upgradeCallback === 'function') {\n            request.onupgradeneeded = (event) => {\n                upgradeCallback(event, db);\n            };\n        }\n    });\n}\nasync function CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n    return new Promise((resolve, reject) => {\n        if (!indexedDB) {\n            return;\n        }\n        const request = indexedDB.open(dbName, version);\n        request.onupgradeneeded = async (event) => {\n            const database = event.target.result;\n            const storeCreationPromises = storeSchemas.map(async (storeSchema) => {\n                if (!database.objectStoreNames.contains(storeSchema.store)) {\n                    const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n                    for (const schema of storeSchema.storeSchema) {\n                        objectStore.createIndex(schema.name, schema.keypath, schema.options);\n                    }\n                }\n            });\n            await Promise.all(storeCreationPromises);\n            const storeMigrations = migrationFactory && migrationFactory();\n            if (storeMigrations) {\n                const migrationKeys = Object.keys(storeMigrations)\n                    .map((k) => parseInt(k, 10))\n                    .filter((v) => v > event.oldVersion)\n                    .sort((a, b) => a - b);\n                for (const v of migrationKeys) {\n                    storeMigrations[v](database, request.transaction);\n                }\n            }\n            database.close();\n            resolve();\n        };\n        request.onsuccess = (e) => {\n            e.target.result.close();\n            resolve();\n        };\n        request.onerror = (error) => {\n            reject(error);\n        };\n    });\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n    if (!dbName || !version || !storeName) {\n        throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n    }\n    return new Observable((obs) => {\n        try {\n            const newVersion = version + 1;\n            const request = indexedDB.open(dbName, newVersion);\n            request.onupgradeneeded = (event) => {\n                const database = event.target.result;\n                database.deleteObjectStore(storeName);\n                database.close();\n                console.log('onupgradeneeded');\n                obs.next(true);\n                obs.complete();\n            };\n            request.onerror = (e) => obs.error(e);\n        }\n        catch (error) {\n            obs.error(error);\n        }\n    });\n}\n\nfunction validateStoreName(db, storeName) {\n    return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n    if (!db) {\n        reject('You need to use the openDatabase function to create a database before you query it!');\n    }\n    if (!validateStoreName(db, storeName)) {\n        reject(`objectStore does not exists: ${storeName}`);\n    }\n}\nfunction createTransaction(db, options) {\n    const trans = db.transaction(options.storeName, options.dbMode);\n    trans.onerror = options.error;\n    trans.onabort = options.abort;\n    return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n    return {\n        storeName,\n        dbMode: type,\n        error: (e) => {\n            reject(e);\n        },\n        abort: (e) => {\n            reject(e);\n        },\n    };\n}\n\nvar DBMode;\n(function (DBMode) {\n    DBMode[\"readonly\"] = \"readonly\";\n    DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\n\nclass NgxIndexedDBService {\n    constructor(dbConfigs, platformId) {\n        this.dbConfigs = dbConfigs;\n        this.platformId = platformId;\n        this.defaultDatabaseName = null;\n        this.isBrowser = isPlatformBrowser(this.platformId);\n        if (this.isBrowser) {\n            this.indexedDB =\n                window.indexedDB ||\n                    window.mozIndexedDB ||\n                    window.webkitIndexedDB ||\n                    window.msIndexedDB;\n            const dbConfigs = Object.values(this.dbConfigs);\n            const isOnlyConfig = dbConfigs.length === 1;\n            for (const dbConfig of dbConfigs) {\n                this.instanciateConfig(dbConfig, isOnlyConfig);\n            }\n        }\n    }\n    async instanciateConfig(dbConfig, isOnlyConfig) {\n        if (!dbConfig.name) {\n            throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n        }\n        if (!dbConfig.version) {\n            throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n        }\n        if ((dbConfig.isDefault ?? false) && this.defaultDatabaseName) {\n            // A default DB is already configured, throw an error\n            throw new Error('NgxIndexedDB: Only one database can be set as default');\n        }\n        if (((dbConfig.isDefault ?? false) && !this.defaultDatabaseName) || isOnlyConfig) {\n            this.defaultDatabaseName = dbConfig.name;\n            this.selectedDb = dbConfig.name;\n        }\n        await CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n        openDatabase(this.indexedDB, dbConfig.name).then((db) => {\n            if (db.version !== dbConfig.version) {\n                if (process.env.NODE_ENV !== 'production') {\n                    console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n                    console.warn(`Using latest version ${db.version}`);\n                }\n                this.dbConfigs[dbConfig.name].version = db.version;\n            }\n        });\n    }\n    get dbConfig() {\n        return this.dbConfigs[this.selectedDb];\n    }\n    /**\n     * The function return the current version of database\n     *\n     * @Return the current version of database as number\n     */\n    getDatabaseVersion() {\n        return new Observable(obs => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                obs.next(db.version);\n                obs.complete();\n            })\n                .catch(err => obs.error(`error during get version of database => ${err} `));\n        });\n    }\n    /**\n     * Selects a database for the current context.\n     * @param {string} [databaseName=undefined] Database name to select.\n     */\n    selectDb(databaseName) {\n        databaseName = databaseName ?? this.defaultDatabaseName;\n        if (!databaseName) {\n            // Name is still null, it means that there is no default database set\n            // and the database name was not specified while calling a method\n            throw new Error(`No database name specified and no default database set.`);\n        }\n        if (!Object.keys(this.dbConfigs).includes(databaseName)) {\n            throw new Error(`NgxIndexedDB: Database ${databaseName} is not initialized.`);\n        }\n        this.selectedDb = databaseName;\n    }\n    /**\n     * Allows to create a new object store ad-hoc\n     * @param storeName The name of the store to be created\n     * @param migrationFactory The migration factory if exists\n     */\n    async createObjectStore(storeSchema, migrationFactory) {\n        const storeSchemas = [storeSchema];\n        await CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n    }\n    /**\n     * Adds new entry in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param value The entry to be added\n     * @param key The optional key for the entry\n     */\n    add(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n                request.onsuccess = async (evt) => {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                    getRequest.onerror = (event) => {\n                        obs.error(event);\n                    };\n                };\n                request.onerror = (event) => {\n                    obs.error(event);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds new entries in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param values The entries to be added containing optional key attribute\n     */\n    bulkAdd(storeName, values) {\n        const promises = new Promise((resolve, reject) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n                const objectStore = transaction.objectStore(storeName);\n                const results = values.map((value) => {\n                    return new Promise((resolve1, reject1) => {\n                        const key = value.key;\n                        delete value.key;\n                        const request = Boolean(key)\n                            ? objectStore.add(value, key)\n                            : objectStore.add(value);\n                        request.onsuccess = (evt) => {\n                            const result = evt.target.result;\n                            resolve1(result);\n                        };\n                    });\n                });\n                resolve(Promise.all(results));\n            })\n                .catch((reason) => reject(reason));\n        });\n        return from(promises);\n    }\n    /**\n     * Delete entries in the store and returns current entries in the store\n     * @param storeName The name of the store to add the item\n     * @param keys The keys to be deleted\n     */\n    bulkDelete(storeName, keys) {\n        const promises = keys.map((key) => {\n            return new Promise((resolve, reject) => {\n                openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                    .then((db) => {\n                    const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n                    const objectStore = transaction.objectStore(storeName);\n                    objectStore.delete(key);\n                    transaction.oncomplete = () => {\n                        this.getAll(storeName)\n                            .pipe(take(1))\n                            .subscribe((newValues) => {\n                            resolve(newValues);\n                        });\n                    };\n                })\n                    .catch((reason) => reject(reason));\n            });\n        });\n        return from(Promise.all(promises));\n    }\n    /**\n     * Returns entry by key.\n     * @param storeName The name of the store to query\n     * @param key The entry key\n     */\n    getByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n                request.onerror = (event) => {\n                    obs.error(event);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Retrieve multiple entries in the store\n     * @param storeName The name of the store to retrieve the items\n     * @param keys The ids entries to be retrieve\n     */\n    bulkGet(storeName, keys) {\n        const observables = keys.map((key) => this.getByKey(storeName, key));\n        return new Observable((obs) => {\n            combineLatest(observables).subscribe((values) => {\n                obs.next(values);\n                obs.complete();\n            });\n        });\n    }\n    /**\n     * Returns entry by id.\n     * @param storeName The name of the store to query\n     * @param id The entry id\n     */\n    getByID(storeName, id) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(id);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns entry by index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param key The entry key.\n     */\n    getByIndex(storeName, indexName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Return all elements from one store\n     * @param storeName The name of the store to select the items\n     */\n    getAll(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.getAll();\n                request.onerror = (evt) => {\n                    obs.error(evt);\n                };\n                request.onsuccess = ({ target: { result: ResultAll } }) => {\n                    obs.next(ResultAll);\n                    obs.complete();\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds or updates a record in store with the given value and key. Return all items present in the store\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     */\n    update(storeName, value) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.put(value);\n                request.onsuccess = async (evt) => {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Adds or updates a record in store with the given value and key. Return all items present in the store\n     * @param storeName The name of the store to update\n     * @param items The values to update in the DB\n     *\n     * @Return The return value is an Observable with the primary key of the object that was last in given array\n     *\n     * @error If the call to bulkPut fails the transaction will be aborted and previously inserted entities will be deleted\n     */\n    bulkPut(storeName, items) {\n        let transaction;\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                items.forEach((item, index) => {\n                    const request = objectStore.put(item);\n                    if (index === items.length - 1) {\n                        request.onsuccess = (evt) => {\n                            transaction.commit();\n                            obs.next(evt.target.result);\n                            obs.complete();\n                        };\n                    }\n                    request.onerror = (evt) => {\n                        transaction.abort();\n                        obs.error(evt);\n                    };\n                });\n            })\n                .catch((reason) => {\n                transaction?.abort();\n                obs.error(reason);\n            });\n        });\n    }\n    /**\n     * Returns all items from the store after delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    delete(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.delete(key);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true from the store after a successful delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    deleteByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                objectStore.delete(key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete all entries from the store.\n     * @param storeName The name of the store to have the entries deleted\n     */\n    clear(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.clear();\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete the DB.\n     */\n    deleteDatabase() {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then(async (db) => {\n                await db.close();\n                const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n                deleteDBRequest.onsuccess = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                deleteDBRequest.onerror = (error) => obs.error(error);\n                deleteDBRequest.onblocked = () => {\n                    throw new Error(`Unable to delete database because it's blocked`);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns the open cursor event\n     * @param storeName The name of the store to have the entries deleted\n     * @param keyRange The key range which the cursor should be open on\n     */\n    openCursor(storeName, keyRange, direction = 'next') {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange, direction);\n                request.onsuccess = (event) => {\n                    obs.next(event);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Open a cursor by index filter.\n     * @param storeName The name of the store to query.\n     * @param indexName The index name to filter.\n     * @param keyRange The range value and criteria to apply on the index.\n     */\n    openCursorByIndex(storeName, indexName, keyRange, direction = 'next', mode = DBMode.readonly) {\n        const obs = new Subject();\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n            .then((db) => {\n            validateBeforeTransaction(db, storeName, (reason) => {\n                obs.error(reason);\n            });\n            const transaction = createTransaction(db, optionsGenerator(mode, storeName, (reason) => {\n                obs.error(reason);\n            }, () => {\n                obs.next();\n            }));\n            const objectStore = transaction.objectStore(storeName);\n            const index = objectStore.index(indexName);\n            const request = index.openCursor(keyRange, direction);\n            request.onsuccess = (event) => {\n                obs.next(event);\n            };\n        })\n            .catch((reason) => obs.error(reason));\n        return obs;\n    }\n    /**\n     * Returns all items by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push(cursor.value);\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all primary keys by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllKeysByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openKeyCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push({ primaryKey: cursor.primaryKey, key: cursor.key });\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    count(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    countByIndex(storeName, indexName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Delete the store by name.\n     * @param storeName The name of the store to query\n     */\n    deleteObjectStore(storeName) {\n        return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.3.4\", ngImport: i0, type: NgxIndexedDBService, deps: [{ token: CONFIG_TOKEN }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.3.4\", ngImport: i0, type: NgxIndexedDBService }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.3.4\", ngImport: i0, type: NgxIndexedDBService, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CONFIG_TOKEN]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }] });\n\nclass NgxIndexedDBModule {\n    static forRoot(...dbConfigs) {\n        const value = {};\n        for (const dbConfig of dbConfigs) {\n            Object.assign(value, { [dbConfig.name]: dbConfig });\n        }\n        return {\n            ngModule: NgxIndexedDBModule,\n            providers: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: value }]\n        };\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.3.4\", ngImport: i0, type: NgxIndexedDBModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.3.4\", ngImport: i0, type: NgxIndexedDBModule, imports: [CommonModule] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.3.4\", ngImport: i0, type: NgxIndexedDBModule, imports: [CommonModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.3.4\", ngImport: i0, type: NgxIndexedDBModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [],\n                    imports: [CommonModule]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
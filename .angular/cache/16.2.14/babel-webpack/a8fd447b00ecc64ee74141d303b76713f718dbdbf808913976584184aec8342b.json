{"ast":null,"code":"import _asyncToGenerator from \"/Users/vajk/Desktop/angular-todoapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n  return new Promise((resolve, reject) => {\n    if (!indexedDB) {\n      reject('IndexedDB not available');\n    }\n    const request = indexedDB.open(dbName, version);\n    let db;\n    request.onsuccess = event => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = event => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = event => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\nfunction CreateObjectStore(_x, _x2, _x3, _x4, _x5) {\n  return _CreateObjectStore.apply(this, arguments);\n}\nfunction _CreateObjectStore() {\n  _CreateObjectStore = _asyncToGenerator(function* (indexedDB, dbName, version, storeSchemas, migrationFactory) {\n    return new Promise((resolve, reject) => {\n      if (!indexedDB) {\n        return;\n      }\n      const request = indexedDB.open(dbName, version);\n      request.onupgradeneeded = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (event) {\n          const database = event.target.result;\n          const storeCreationPromises = storeSchemas.map( /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* (storeSchema) {\n              if (!database.objectStoreNames.contains(storeSchema.store)) {\n                const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n                for (const schema of storeSchema.storeSchema) {\n                  objectStore.createIndex(schema.name, schema.keypath, schema.options);\n                }\n              }\n            });\n            return function (_x10) {\n              return _ref5.apply(this, arguments);\n            };\n          }());\n          yield Promise.all(storeCreationPromises);\n          const storeMigrations = migrationFactory && migrationFactory();\n          if (storeMigrations) {\n            const migrationKeys = Object.keys(storeMigrations).map(k => parseInt(k, 10)).filter(v => v > event.oldVersion).sort((a, b) => a - b);\n            for (const v of migrationKeys) {\n              storeMigrations[v](database, request.transaction);\n            }\n          }\n          database.close();\n          resolve();\n        });\n        return function (_x9) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n      request.onsuccess = e => {\n        e.target.result.close();\n        resolve();\n      };\n      request.onerror = error => {\n        reject(error);\n      };\n    });\n  });\n  return _CreateObjectStore.apply(this, arguments);\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n  if (!dbName || !version || !storeName) {\n    throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n  }\n  return new Observable(obs => {\n    try {\n      const newVersion = version + 1;\n      const request = indexedDB.open(dbName, newVersion);\n      request.onupgradeneeded = event => {\n        const database = event.target.result;\n        database.deleteObjectStore(storeName);\n        database.close();\n        console.log('onupgradeneeded');\n        obs.next(true);\n        obs.complete();\n      };\n      request.onerror = e => obs.error(e);\n    } catch (error) {\n      obs.error(error);\n    }\n  });\n}\nfunction validateStoreName(db, storeName) {\n  return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\nfunction createTransaction(db, options) {\n  const trans = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.onabort = options.abort;\n  return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n  return {\n    storeName,\n    dbMode: type,\n    error: e => {\n      reject(e);\n    },\n    abort: e => {\n      reject(e);\n    }\n  };\n}\nvar DBMode = /*#__PURE__*/function (DBMode) {\n  DBMode[\"readonly\"] = \"readonly\";\n  DBMode[\"readwrite\"] = \"readwrite\";\n  return DBMode;\n}(DBMode || {});\nconst CONFIG_TOKEN = new InjectionToken(null);\nlet NgxIndexedDBService = /*#__PURE__*/(() => {\n  class NgxIndexedDBService {\n    constructor(dbConfigs, platformId) {\n      this.dbConfigs = dbConfigs;\n      this.platformId = platformId;\n      this.defaultDatabaseName = null;\n      this.isBrowser = isPlatformBrowser(this.platformId);\n      if (this.isBrowser) {\n        this.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n        const dbConfigs = Object.values(this.dbConfigs);\n        const isOnlyConfig = dbConfigs.length === 1;\n        for (const dbConfig of dbConfigs) {\n          this.instanciateConfig(dbConfig, isOnlyConfig);\n        }\n      }\n    }\n    instanciateConfig(dbConfig, isOnlyConfig) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!dbConfig.name) {\n          throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n        }\n        if (!dbConfig.version) {\n          throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n        }\n        if ((dbConfig.isDefault ?? false) && _this.defaultDatabaseName) {\n          // A default DB is already configured, throw an error\n          throw new Error('NgxIndexedDB: Only one database can be set as default');\n        }\n        if ((dbConfig.isDefault ?? false) && !_this.defaultDatabaseName || isOnlyConfig) {\n          _this.defaultDatabaseName = dbConfig.name;\n          _this.selectedDb = dbConfig.name;\n        }\n        yield CreateObjectStore(_this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n        openDatabase(_this.indexedDB, dbConfig.name).then(db => {\n          if (db.version !== dbConfig.version) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n              console.warn(`Using latest version ${db.version}`);\n            }\n            _this.dbConfigs[dbConfig.name].version = db.version;\n          }\n        });\n      })();\n    }\n    get dbConfig() {\n      return this.dbConfigs[this.selectedDb];\n    }\n    /**\n     * The function return the current version of database\n     *\n     * @Return the current version of database as number\n     */\n    getDatabaseVersion() {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          obs.next(db.version);\n          obs.complete();\n        }).catch(err => obs.error(`error during get version of database => ${err} `));\n      });\n    }\n    /**\n     * Selects a database for the current context.\n     * @param {string} [databaseName=undefined] Database name to select.\n     */\n    selectDb(databaseName) {\n      databaseName = databaseName ?? this.defaultDatabaseName;\n      if (!databaseName) {\n        // Name is still null, it means that there is no default database set\n        // and the database name was not specified while calling a method\n        throw new Error(`No database name specified and no default database set.`);\n      }\n      if (!Object.keys(this.dbConfigs).includes(databaseName)) {\n        throw new Error(`NgxIndexedDB: Database ${databaseName} is not initialized.`);\n      }\n      this.selectedDb = databaseName;\n    }\n    /**\n     * Allows to create a new object store ad-hoc\n     * @param storeName The name of the store to be created\n     * @param migrationFactory The migration factory if exists\n     */\n    createObjectStore(storeSchema, migrationFactory) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const storeSchemas = [storeSchema];\n        yield CreateObjectStore(_this2.indexedDB, _this2.dbConfig.name, ++_this2.dbConfig.version, storeSchemas, migrationFactory);\n      })();\n    }\n    /**\n     * Adds new entry in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param value The entry to be added\n     * @param key The optional key for the entry\n     */\n    add(storeName, value, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n          request.onsuccess = /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (evt) {\n              const result = evt.target.result;\n              const getRequest = objectStore.get(result);\n              getRequest.onsuccess = event => {\n                obs.next(event.target.result);\n                obs.complete();\n              };\n              getRequest.onerror = event => {\n                obs.error(event);\n              };\n            });\n            return function (_x6) {\n              return _ref.apply(this, arguments);\n            };\n          }();\n          request.onerror = event => {\n            obs.error(event);\n          };\n        }).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Adds new entries in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param values The entries to be added containing optional key attribute\n     */\n    bulkAdd(storeName, values) {\n      const promises = new Promise((resolve, reject) => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n          const objectStore = transaction.objectStore(storeName);\n          const results = values.map(value => {\n            return new Promise((resolve1, reject1) => {\n              const key = value.key;\n              delete value.key;\n              const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n              request.onsuccess = evt => {\n                const result = evt.target.result;\n                resolve1(result);\n              };\n            });\n          });\n          resolve(Promise.all(results));\n        }).catch(reason => reject(reason));\n      });\n      return from(promises);\n    }\n    /**\n     * Delete entries in the store and returns current entries in the store\n     * @param storeName The name of the store to add the item\n     * @param keys The keys to be deleted\n     */\n    bulkDelete(storeName, keys) {\n      const promises = keys.map(key => {\n        return new Promise((resolve, reject) => {\n          openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n            const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n            const objectStore = transaction.objectStore(storeName);\n            objectStore.delete(key);\n            transaction.oncomplete = () => {\n              this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n                resolve(newValues);\n              });\n            };\n          }).catch(reason => reject(reason));\n        });\n      });\n      return from(Promise.all(promises));\n    }\n    /**\n     * Returns entry by key.\n     * @param storeName The name of the store to query\n     * @param key The entry key\n     */\n    getByKey(storeName, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.get(key);\n          request.onsuccess = event => {\n            obs.next(event.target.result);\n            obs.complete();\n          };\n          request.onerror = event => {\n            obs.error(event);\n          };\n        }).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Retrieve multiple entries in the store\n     * @param storeName The name of the store to retrieve the items\n     * @param keys The ids entries to be retrieve\n     */\n    bulkGet(storeName, keys) {\n      const observables = keys.map(key => this.getByKey(storeName, key));\n      return new Observable(obs => {\n        combineLatest(observables).subscribe(values => {\n          obs.next(values);\n          obs.complete();\n        });\n      });\n    }\n    /**\n     * Returns entry by id.\n     * @param storeName The name of the store to query\n     * @param id The entry id\n     */\n    getByID(storeName, id) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.get(id);\n          request.onsuccess = event => {\n            obs.next(event.target.result);\n          };\n        }).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Returns entry by index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param key The entry key.\n     */\n    getByIndex(storeName, indexName, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.get(key);\n          request.onsuccess = event => {\n            obs.next(event.target.result);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Return all elements from one store\n     * @param storeName The name of the store to select the items\n     */\n    getAll(storeName) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.getAll();\n          request.onerror = evt => {\n            obs.error(evt);\n          };\n          request.onsuccess = ({\n            target: {\n              result: ResultAll\n            }\n          }) => {\n            obs.next(ResultAll);\n            obs.complete();\n          };\n        }).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Adds or updates a record in store with the given value and key. Return all items present in the store\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     */\n    update(storeName, value) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.put(value);\n          request.onsuccess = /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (evt) {\n              const result = evt.target.result;\n              const getRequest = objectStore.get(result);\n              getRequest.onsuccess = event => {\n                obs.next(event.target.result);\n                obs.complete();\n              };\n            });\n            return function (_x7) {\n              return _ref2.apply(this, arguments);\n            };\n          }();\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Adds or updates a record in store with the given value and key. Return all items present in the store\n     * @param storeName The name of the store to update\n     * @param items The values to update in the DB\n     *\n     * @Return The return value is an Observable with the primary key of the object that was last in given array\n     *\n     * @error If the call to bulkPut fails the transaction will be aborted and previously inserted entities will be deleted\n     */\n    bulkPut(storeName, items) {\n      let transaction;\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          items.forEach((item, index) => {\n            const request = objectStore.put(item);\n            if (index === items.length - 1) {\n              request.onsuccess = evt => {\n                transaction.commit();\n                obs.next(evt.target.result);\n                obs.complete();\n              };\n            }\n            request.onerror = evt => {\n              transaction.abort();\n              obs.error(evt);\n            };\n          });\n        }).catch(reason => {\n          transaction?.abort();\n          obs.error(reason);\n        });\n      });\n    }\n    /**\n     * Returns all items from the store after delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    delete(storeName, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.delete(key);\n          transaction.oncomplete = () => {\n            this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n              obs.next(newValues);\n              obs.complete();\n            });\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns true from the store after a successful delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    deleteByKey(storeName, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          transaction.oncomplete = () => {\n            obs.next(true);\n            obs.complete();\n          };\n          objectStore.delete(key);\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns true if successfully delete all entries from the store.\n     * @param storeName The name of the store to have the entries deleted\n     */\n    clear(storeName) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.clear();\n          transaction.oncomplete = () => {\n            obs.next(true);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns true if successfully delete the DB.\n     */\n    deleteDatabase() {\n      var _this3 = this;\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (db) {\n            yield db.close();\n            const deleteDBRequest = _this3.indexedDB.deleteDatabase(_this3.dbConfig.name);\n            deleteDBRequest.onsuccess = () => {\n              obs.next(true);\n              obs.complete();\n            };\n            deleteDBRequest.onerror = error => obs.error(error);\n            deleteDBRequest.onblocked = () => {\n              throw new Error(`Unable to delete database because it's blocked`);\n            };\n          });\n          return function (_x8) {\n            return _ref3.apply(this, arguments);\n          };\n        }()).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Returns the open cursor event\n     * @param storeName The name of the store to have the entries deleted\n     * @param keyRange The key range which the cursor should be open on\n     */\n    openCursor(storeName, keyRange, direction = 'next') {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange, direction);\n          request.onsuccess = event => {\n            obs.next(event);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Open a cursor by index filter.\n     * @param storeName The name of the store to query.\n     * @param indexName The index name to filter.\n     * @param keyRange The range value and criteria to apply on the index.\n     */\n    openCursorByIndex(storeName, indexName, keyRange, direction = 'next', mode = DBMode.readonly) {\n      const obs = new Subject();\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, reason => {\n          obs.error(reason);\n        });\n        const transaction = createTransaction(db, optionsGenerator(mode, storeName, reason => {\n          obs.error(reason);\n        }, () => {\n          obs.next();\n        }));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openCursor(keyRange, direction);\n        request.onsuccess = event => {\n          obs.next(event);\n        };\n      }).catch(reason => obs.error(reason));\n      return obs;\n    }\n    /**\n     * Returns all items by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllByIndex(storeName, indexName, keyRange) {\n      const data = [];\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.openCursor(keyRange);\n          request.onsuccess = event => {\n            const cursor = event.target.result;\n            if (cursor) {\n              data.push(cursor.value);\n              cursor.continue();\n            } else {\n              obs.next(data);\n              obs.complete();\n            }\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns all primary keys by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllKeysByIndex(storeName, indexName, keyRange) {\n      const data = [];\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.openKeyCursor(keyRange);\n          request.onsuccess = event => {\n            const cursor = event.target.result;\n            if (cursor) {\n              data.push({\n                primaryKey: cursor.primaryKey,\n                key: cursor.key\n              });\n              cursor.continue();\n            } else {\n              obs.next(data);\n              obs.complete();\n            }\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    count(storeName, keyRange) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.count(keyRange);\n          request.onerror = e => obs.error(e);\n          request.onsuccess = e => {\n            obs.next(e.target.result);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    countByIndex(storeName, indexName, keyRange) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.count(keyRange);\n          request.onerror = e => obs.error(e);\n          request.onsuccess = e => {\n            obs.next(e.target.result);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Delete the store by name.\n     * @param storeName The name of the store to query\n     */\n    deleteObjectStore(storeName) {\n      return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n    }\n    static #_ = this.ɵfac = function NgxIndexedDBService_Factory(t) {\n      return new (t || NgxIndexedDBService)(i0.ɵɵinject(CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID));\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgxIndexedDBService,\n      factory: NgxIndexedDBService.ɵfac\n    });\n  }\n  return NgxIndexedDBService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxIndexedDBModule = /*#__PURE__*/(() => {\n  class NgxIndexedDBModule {\n    static forRoot(...dbConfigs) {\n      const value = {};\n      for (const dbConfig of dbConfigs) {\n        Object.assign(value, {\n          [dbConfig.name]: dbConfig\n        });\n      }\n      return {\n        ngModule: NgxIndexedDBModule,\n        providers: [NgxIndexedDBService, {\n          provide: CONFIG_TOKEN,\n          useValue: value\n        }]\n      };\n    }\n    static #_ = this.ɵfac = function NgxIndexedDBModule_Factory(t) {\n      return new (t || NgxIndexedDBModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgxIndexedDBModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule]\n    });\n  }\n  return NgxIndexedDBModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };\n//# sourceMappingURL=ngx-indexed-db.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}